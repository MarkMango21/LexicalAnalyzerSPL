/* $Id: spl_lexer_definitions_top.l,v 1.4 2024/10/06 19:16:25 leavens Exp leavens $ */
/* Lexical Analyzer for SPL */

%option header-file = "spl_lexer.h"
%option outfile = "spl_lexer.c"
%option yylineno
%option bison-bridge

%{
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <assert.h>
#include <limits.h>
#include "ast.h"
#include "parser_types.h"
#include "utilities.h"
#include "lexer.h"
 /* Tokens generated by Bison */
#include "spl.tab.h"

 /* need declaration of fileno, part of the C standard library.
   (Putting an extern declaration here shuts off a gcc warning.) */
extern int fileno(FILE *stream);

/* The filename of the file being read */
static char *input_filename;

/* Have any errors been noted? */
static bool errors_noted;

/* The value of a token */
extern YYSTYPE yylval;

/* The FILE used by the generated lexer */
extern FILE *yyin;

// We are not using yyunput or input
#define YY_NO_UNPUT
#define YY_NO_INPUT

#undef yywrap   /* sometimes a macro by default */

// apparently strdup is not declared in <string.h>
extern char *strdup(const char *s);

// set the lexer's value for a token in yylval as an AST
static void tok2ast(int code) {
    AST t;
    t.token.file_loc = file_location_make(input_filename, yylineno);
    t.token.type_tag = token_ast;
    t.token.code = code;
    t.token.text = strdup(yytext);
    yylval = t;
}

static void ident2ast(const char *name) {
    AST t;
    assert(input_filename != NULL);
    t.ident.file_loc = file_location_make(input_filename, yylineno);
    t.ident.type_tag = ident_ast;
    t.ident.name = strdup(name);
    yylval = t;
}

static void number2ast(unsigned int val)
{
    AST t;
    t.number.file_loc = file_location_make(input_filename, yylineno);
    t.number.type_tag = number_ast;
    t.number.text = strdup(yytext);
    t.number.value = val;
    yylval = t;
}

%}

 /* you can add actual definitions below, before the %% */

DIGIT               [0-9]
LETTER              [a-zA-Z]
NUMBER              {DIGIT}{DIGIT}*
LETTER-OR-DIGIT     {LETTER}|{DIGIT}
IDENT               {LETTER}{LETTER-OR-DIGIT}*
PLUS                \+
MINUS               \-
MULT                \*
DIV                 \/
NEWLINE             \n
CR                  \r
EOL                 ({NEWLINE}|({CR}{NEWLINE}))
PUNCTUATION         [.|;|=|,|:|(|)]


 /* the rules section starts after the %% below */

%%

 /* Rules Section */

{IDENT}            { if(is_reserved_word(yytext))
                      {
			tok2ast(return_reservedW_symbol(yytext));
			return return_reservedW_symbol(yytext);
                      }
		     else
		      {
			ident2ast(yytext);
                        return identsym;
		      } 
                   }
{EOL}              ;/*Ignores End of the line elements*/
{NUMBER}           { number2ast(atoi(yytext)); return numbersym; }
{PLUS}             { tok2ast(plussym); return plussym; }
{MINUS}            { tok2ast(minussym); return minussym; }
{MULT}             { tok2ast(multsym); return multsym; }
{DIV}              { tok2ast(divsym); return divsym; }
":="		   { tok2ast(becomessym); return becomessym; }
"=="               { tok2ast(eqeqsym); return eqeqsym; }
"!="  		   { tok2ast(neqsym); return neqsym; }
"<"		   { tok2ast(ltsym); return ltsym; }
"<="		   { tok2ast(leqsym); return leqsym; }
">"		   { tok2ast(gtsym); return gtsym; }
">="               { tok2ast(geqsym); return geqsym; }
{PUNCTUATION}      { tok2ast(returnPsymbol(yytext));return returnPsymbol(yytext); } // If single-character punctuation
[ \t]              ; // Ignore whitespace
"%"[^\n]*        ; // Ignore comments starting with % until the newline
.                  {yyerror(input_filename,"invalid character"); } // Catch-all for unrecognized characters

%%

 /* This code goes in the user code section of the spl_lexer.l file,
   following the last %% above. */

// Requires: fname != NULL
// Requires: fname is the name of a readable file
// Initialize the lexer and start it reading
// from the given file name
void lexer_init(char *fname)
{
    errors_noted = false;
    yyin = fopen(fname, "r");
    if (yyin == NULL) {
	bail_with_error("Cannot open %s", fname);
    }
    input_filename = fname;
}

// Close the file yyin
// and return 0 to indicate that there are no more files
int yywrap() {
    if (yyin != NULL) {
	int rc = fclose(yyin);
	if (rc == EOF) {
	    bail_with_error("Cannot close %s!", input_filename);
	}
    }
    input_filename = NULL;
    return 1;  /* no more input */
}

// Return the name of the current input file
const char *lexer_filename() {
    return input_filename;
}

// Return the line number of the next token
unsigned int lexer_line() {
    return yylineno;
}

/* Report an error to the user on stderr */
void yyerror(const char *filename, const char *msg)
{
    fflush(stdout);
    fprintf(stderr, "%s:%d: %s '%c' ('\\0%o') \n", input_filename, lexer_line(), msg,*yytext,*yytext);//Ojo
    errors_noted = true;
}

// On standard output:
// Print a message about the file name of the lexer's input
// and then print a heading for the lexer's output.
void lexer_print_output_header()
{
    printf("Tokens from file %s\n", lexer_filename());
    printf("%-6s %-4s  %s\n", "Number", "Line", "Text");
}

// Have any errors been noted by the lexer?
bool lexer_has_errors()
{
    return errors_noted;
}

// Print information about the token t to stdout
// followed by a newline
void lexer_print_token(enum yytokentype t, unsigned int tline,
		       const char *txt)
{
    printf("%-6d %-4d \"%s\"\n", t, tline, txt);
}


/* Read all the tokens from the input file
 * and print each token on standard output
 * using the format in lexer_print_token */
void lexer_output()
{
    lexer_print_output_header();
    AST dummy;
    yytoken_kind_t t;
    do {
	t = yylex(&dummy);
	if (t == YYEOF) {
	    break;
        }
        lexer_print_token(t, yylineno, yytext);
    } while (t != YYEOF);
}
/*Reads the yytext content and returns 1 if the inde is a reserved word
 If the word isn't a reserved word then return 0*/
int is_reserved_word(const char *ident) 
{
   if(strcmp(ident,"const")==0)
   {
	return 1;
   }
   else if(strcmp(ident,"var")==0)
   {
	return 1;
   }
   else if(strcmp(ident,"proc")==0)
   {
	return 1;
   }
   else if(strcmp(ident,"call")==0)
   {
	return 1;
   }
   else if(strcmp(ident,"begin")==0)
   {
	return 1;
   }
   else if(strcmp(ident,"end")==0)
   {
	return 1;
   }
   else if(strcmp(ident,"if")==0)
   {
	return 1;
   }
   else if(strcmp(ident,"then")==0)
   {
	return 1;
   }
   else if(strcmp(ident,"else")==0)
   {
	return 1;
   }
   else if(strcmp(ident,"while")==0)
   {
	return 1;
   }
   else if(strcmp(ident,"do")==0)
   {
	return 1;
   }
   else if(strcmp(ident,"read")==0)
   {
	return 1;
   }
   else if(strcmp(ident,"print")==0)
   {
	return 1;
   }
   else if(strcmp(ident,"divisible")==0)
   {
	return 1;
   }
   else if(strcmp(ident,"by")==0)
   {
	return 1;
   }
 return 0;
}
/*Function to return the symbol enum type from the reserved words 
into the tok2ast function/parser*/
enum yytokentype return_reservedW_symbol(const char *word)
{
   if(strcmp(word,"const")==0)
   {
	return constsym;
   }
   else if(strcmp(word,"var")==0)
   {
	return varsym;
   }
   else if(strcmp(word,"proc")==0)
   {
	return procsym;
   }
   else if(strcmp(word,"call")==0)
   {
	return callsym;
   }
   else if(strcmp(word,"var")==0)
   {
	return varsym;
   }
   else if(strcmp(word,"begin")==0)
   {
	return beginsym;
   }
   else if(strcmp(word,"end")==0)
   {
	return endsym;
   }
   else if(strcmp(word,"if")==0)
   {
	return ifsym;
   }
   else if(strcmp(word,"then")==0)
   {
	return thensym;
   }
   else if(strcmp(word,"else")==0)
   {
	return elsesym;
   }
   else if(strcmp(word,"while")==0)
   {
	return whilesym;
   }
   else if(strcmp(word,"do")==0)
   {
	return dosym;
   }
   else if(strcmp(word,"read")==0)
   {
	return readsym;
   }
   else if(strcmp(word,"print")==0)
   {
	return printsym;
   }
   else if(strcmp(word,"divisible")==0)
   {
	return divisiblesym;
   }
   else if(strcmp(word,"by")==0)
   {
	return bysym;
   }
 return identsym;
 
}

/*Read the puntuation symbols in the .spl files
returns the token symbol into tok2ast and the parser*/
enum yytokentype returnPsymbol(const char *punctuation)
{
   switch (*punctuation)
        {
        case '.':
            return periodsym;
            break;
        case ';':
            return semisym;
            break;
        case '=':
            return eqsym;
            break;
        case ',':
            return commasym;
            break;
        case '(':
            return lparensym;
            break;
        case ')':
            return rparensym;
            break;
        default:
	    yyerror(input_filename,"invalid character");
        }
  return periodsym;
}
